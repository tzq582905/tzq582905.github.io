[{"title":"动态更新包，管理设计","date":"2018-01-23T02:11:54.000Z","path":"2018/01/23/动态更新包，管理设计/","text":"流程打包机打包 ==&gt; web端录入，加密上传 ==&gt; app端获取 ==&gt; 服务端下发 ==&gt; 本地加载补丁，并改本地配置。 数据结构db:表1，bundle 主键 funcId+bundleVersion+appPlatform funcId(bundle包的功能id), bundleVersion(模块的版本), platform(ios/android), supportMinV(最低支持app版本), createTime, updateTime, desc 表2,patch funcId(bundle包的功能id), bundleVersion(哪个版本的补丁包), patchVersion(补丁包版本), appPlatforms(ios/android), createTime, updateTime, desc 打包机：打包，生成全量包以及各增量包。 需要项目下有版本的配置文件。 /qianzhuang /ios /bundle /0.1.0 /0.2.0 /0.3.0 0.3.0.zip config /patch /0.1.0 /0.2.0 /0.3.0 0.1.0-0.3.0.zip 0.2.0-0.3.0.zip config:{ “funcId”: “qianzhuang”, “v”: “0.3.0”, //版本 “min-v”: “4.0.0”, //此版本要求的最小app版本 “platform”: “ios”, “date”: “2016-01-01”, //打包日期 “des”: [ “修复xxbug” ]} web：录入funcId(bundle包的功能id), bundleVersion(模块的版本), platform(ios/android), desc, supportMinV(最低支持app版本,需要开发人员提供), patchVersion （一次产生N补丁包条数据。） 上传补丁包，0.1.0-0.3.0.zip 0.2.0-0.3.0.zip 上传bundle包 app端:就以bundle的tag作为版本号。本地记录一个bundle的版本号 app启动任务，后台切换到前台任务。 =&gt;本地bundle的版本号 、funcId+appVersion+platform 获取最新包的url。 服务端：api: 本地bundle的版本号 、funcId 、 appVersion 、 platform =&gt; return url; 1、根据funcId+appVersion+platform 获取支持当前版本的bundle包的版本列表。 2、根据本地bundle的版本号，获取最新的可更新的版本。 3、patchVersion == 本地bundle的版本号-最新的可更新的版本 4、组装url 整个bundle url /funId/platform/bundle/bundleVersion/bundleVersion.zip 补丁包url /funId/platform/patch/bundleVersion/patchVersion.zip","tags":[]},{"title":"ios私有库研究","date":"2017-07-16T14:00:00.000Z","path":"2017/07/16/ios私有库研究/","text":"私有API是指放在PrivateFrameworks框架中的API，虽然放在Frameworks框架中，但是却没有在苹果的官方文档中有使用说明、代码介绍等记录的API。注意：私有API有些还不够成熟，随时有可能会变动，就是系统版本升级后可能会失效。而有些是涉及隐私等，苹果不愿意公开。使用私有API会面临审核通不过然后不能上线，但是也有使用私有API通过审核. 使用介绍ios系统中的位置私有api：/System/Library/PrivateFrameworks 公共api：/System/Library/Frameworks 使用 因为在SDK中未暴露，所以是无法直接在xcode中加载到的。需要手动代码加载。就以iphone蓝牙状态为例，如何获取到蓝牙状态。 1、加载到对应私有framework 123456789NSBundle *b = [NSBundle bundleWithPath:[@&quot;/System/Library/PrivateFrameworks&quot; stringByAppendingPathComponent:@&quot;GameKitServices.framework&quot;]]; if([b isLoaded] == NO) &#123; NSError *error = nil; BOOL success = [b loadAndReturnError:&amp;error]; if (success) &#123; NSLog(@&quot;success&quot;); &#125; &#125; 2、动态调用 123456Class btclass = NSClassFromString(@&quot;GKBluetoothSupport&quot;); if ([btclass respondsToSelector:@selector(bluetoothStatus)]) &#123; BOOL bluetooth = ((int)[btclass performSelector:@selector(bluetoothStatus)] &amp; 1) != 0; printf(&quot;Bluetooth %s enabled\\n&quot;, bluetooth ? &quot;is&quot; : &quot;isn&apos;t&quot;); &#125; 苹果如何审核是否使用了私有api 苹果会扫描二进制文件中是否有私有库 检测一些链接标识。 检测selector和字符串。 曾经在苹果工作的员工介绍如何审核 上线appstore都知道，使用私有api会影响上线appstore但如果有些功能确实项目需要，并且不侵犯用户隐私。也是可以绕过苹果审核的。知道了苹果如何检测，也应该知道具体怎么做了吧。 提供的账号不会运行到以上代码 framework path，类，方法的字符串做处理。 iOS-Runtime-Headers","tags":[]},{"title":"cnpm搭建","date":"2017-05-08T13:00:00.000Z","path":"2017/05/08/cnpm搭建/","text":"npm是nodejs的包管理工具。cnpm是用Nodejs写的一个npm的镜像服务，可定期同步公有库，同时也支持公司内部发布私有库。 系统环境 工具 版本 Linux CentOS release 6.5 nodejs v5.4.1 npm 3.3.12 mysql 5.1.73 环境搭建nodejs安装1、使用编译好的二进制包 wget https://nodejs.org/download/release/latest/node-v5.4.1-linux-x64.tar.xz tar -zxvf node-v5.4.1-linux-x64.tar.xz tar –strip-components 1 -xzvf node-v5.4.1-linux-x64.tar.gz -C /usr/local ln -s /usr/local/bin/node /usr/bin/node 或者 将/usr/local/bin添加到全局环境变量中 node -v 查看最终结果 2、源码编译安装 wget https://nodejs.org/download/release/latest/node-v5.4.1.tar.xz tar -zxvf node-v5.4.1.tar.xz cd node-v5.4.1 ./configure 检查当前的环境是否满足要安装软件的依赖关系,并进行配置 make &amp;&amp; make install (可能因为g++，python等软件环境的版本问题，安装不成功) ln -s /usr/local/bin/node /usr/bin/node node -v 3、使用yum/apt-get/nvm/homebrew等包管理工具安装(这里只介绍yum安装，yum基本上装机自带的。) 使用epel软件源 yum install epel-release yum install http://mirrors.hustunique.com/epel/6/x86_64/epel-release-6-8.noarch.rpm yum install nodejs mysql安装1、查看有没有安装过： yum list installed mysql* rpm -qa | grep mysql* 2、查看有没有安装包： yum list mysql* 3、安装mysql客户端： yum install mysql 4、安装mysql 服务器端： yum install mysql-server yum install mysql-devel 5、mysql配置文件/etc/my.cnf中加入default-character-set=utf8 6、启动mysql服务： service mysqld start chkconfig mysqld on chkconfig mysqld off 7、查看开机启动设置是否成功 chkconfig --list | grep mysql* 使用 mysql -u root -p npm安装 yum install npm curl https://npmjs.org/install.sh | sudo sh 服务搭建1、下载源码 git clone https://github.com/cnpm/cnpmjs.org.git cd cnpmjs.org 2、npm升级，安装依赖 npm install npm -g npm install 3、创建数据库 用户名root 密码mysql mysql -uroot -pmysql -e ‘DROP DATABASE IF EXISTS cnpmjs_test;’ mysql -uroot -pmysql -e ‘CREATE DATABASE cnpmjs_test;’ mysql -uroot -pmysql ‘cnpmjs_test’ &lt; docs/db.sql mysql -uroot -pmysql ‘cnpmjs_test’ -e ‘show tables;’ 4、修改配置文件 cnpmjs.org/config/index.js 下配置数据库地址、账号、密码 配置admin的账号 bindingHost绑定地址修改为本机地址。 5、启动服务 nohup node –harmony dispatch.js &amp; 6、因防火墙限制，需修改iptables 1234/etc/sysconfig/iptables-I INPUT -p tcp --dport 7001 -j ACCEPT-I INPUT -p tcp --dport 7002 -j ACCEPT 客户端使用1、服务地址: localhost:7002 2、下面的本地配置，对应修改连接，可放入~/.zshrc &amp;&amp; source ~/.zshrc 1234alias cnpm=&quot;npm --registry=http://localhost:7001 \\--cache=$HOME/.npm/.cache/cnpm \\--disturl=http://registry.npm.taobao.org/mirrors/node \\--userconfig=$HOME/.cnpmrc&quot; 3、具体cnpm的使用命令与npm的相同 npm install =&gt; cnpm install 4、发布项目需要在项目名前加scope，目前只支持‘@cnpm’, ‘@cnpmtest’, ‘@cnpm-test’,可配置 例如 name : ‘@cnpmtest/testpublish’","tags":[]},{"title":"reactNative总结","date":"2017-05-07T13:00:00.000Z","path":"2017/05/07/reactNative/","text":"##环境搭建一、调试环境 Node、watchman、chrome 二、开发环境 1、原生开发环境。 2、Atom安装Nuclide插件。或者webstorm,装reactnative相关配置文件。 ##认识目录结构与服务启动react-native init AwesomeProject npm install npm start npm start – –reset-cache ##和原生app集成打包命令：react-native bundle –entry-file index.ios.js –bundle-output./iOSReleaseBundle/index.ios.jsbundle–platform ios –assets-dest ./iOSReleaseBundle –dev false一、iOS1、通过cocoapods导入。 pod ‘rn_myTradeDebug’,’~&gt;0.0.3’, :configurations =&gt; [‘Debug’] pod ‘rn_myTrade’,’~&gt;0.0.3’, :configurations =&gt; [‘Release’,’Ad-hoc’]二、android通过grandle工具导入maven库。 ##认识代码结构const React = require(‘react’);const ReactNative = require(‘react-native’); const {Component} = React; const { AppRegistry,} = ReactNative; class HelloWorldApp extends Component { render() { return ( Hello world! ); }} AppRegistry.registerComponent(‘HelloWorldApp’, () =&gt; HelloWorldApp); ##React原生交互 实现协议1234567891011121314@implementation APSLnkInvokeRCT_EXPORT_MODULE();- (dispatch_queue_t)methodQueue&#123; return dispatch_queue_create(&quot;me.andpay.RN.Lnk.concurrent&quot;, DISPATCH_QUEUE_SERIAL);&#125;RCT_EXPORT_METHOD(invokeEvent:(NSArray *)command response:(RCTResponseSenderBlock)response)&#123; response(@[[NSNull null],result]);&#125;@end ##ReactNative性能问题 1、异步逐层渲染组件react-progressive 2、静态组件使用shouldComponentUpdate，返回false使其只渲染一次 3、一些手势拖拽操作，setNativeProps，直接修改dom 4、尽量不使用阴影效果 5、组件粒度话，区分出动态和静态组件。 ##优缺点1、使用reactnative确实可以做到一次学习，多平台开发。 (ios,android,web)。 2、但不是为了一份代码，多处使用。比如ios和android的区别就是一些控件和控件属性需要区分对待。 3、一次编译，就可以持续修改和调试。使用chrome debug。 4、支持热更新。 缺点 1、Native到Web，要做很多概念转换，势必造成双方都要妥协。最终要用一套CSS的阉割版。 2、原生组件的接口，有些没有暴露，所以不是所有原生可以实现的，在这都可以实现。 3、react中如何进行crash的一些收集。 ##React异常收集 const ErrorUtils = require(‘ErrorUtils’); ErrorUtils.setGlobalHandler(handleError); ##资料 React-Native学习指南 一些已有项目demo react-native课堂 旅行喵 React Native 技术实践 reactnative中文网 虚拟DOM diff算法 虚拟DOM diff算法","tags":[]},{"title":"原来你是这样的ReactJS","date":"2017-04-13T13:00:00.000Z","path":"2017/04/13/react/","text":"2013年5月，facebook开源的在开发Instagram时使用的前端框架。 虚拟DOM（Virtual DOM）和组件化的开发的是React的两个特点。 ##虚拟DOM 在浏览器端用Javascript实现了一套DOM API。基于React进行开发时所有的DOM构造都是通过虚拟DOM进行。也就是通过JSX进行构造。 页面刷新过程：数据源变化=&gt;重新生成整个虚拟DOM=&gt;与旧DOM对比=&gt;只重绘变化的部分 性能高的原因： 批处理虚拟DOM的刷新，会将一些无效的变化过滤 虚拟DOM是内存数据，处理速度快。 一套高效的diff算法，对实际DOM的渲染，只渲染变化的部分。 ##组件化开发 组件的状态、属性、生命周期、组件嵌套。 1234567891011121314151617181920212223242526272829303132333435&lt;script type=&quot;text/babel&quot;&gt; var Hello = React.createClass(&#123; getInitialState: function () &#123; return &#123; opacity: 1.0 &#125;; &#125;, componentDidMount: function () &#123; this.timer = setInterval(function () &#123; var opacity = this.state.opacity; opacity -= .05; if (opacity &lt; 0.1) &#123; opacity = 1.0; &#125; this.setState(&#123; opacity: opacity &#125;); &#125;.bind(this), 100); &#125;, render: function () &#123; return ( &lt;div style=&#123;&#123;opacity: this.state.opacity&#125;&#125;&gt; Hello &#123;this.props.name&#125; &lt;/div&gt; ); &#125; &#125;); ReactDOM.render( &lt;Hello name=&quot;world&quot;/&gt;, document.getElementById(&apos;example&apos;) ); &lt;/script&gt; ##JSX(像 XML 的 JavaScript 语法扩展) 123456789var Nav, Profile;// 输入 (JSX):var app = &lt;Nav color=&quot;blue&quot;&gt;&lt;Profile&gt;click&lt;/Profile&gt;&lt;/Nav&gt;;// 输出 (JS):var app = React.createElement( Nav, &#123;color:&quot;blue&quot;&#125;, React.createElement(Profile, null, &quot;click&quot;)); ##与angular比较 同是Model Driven View的设计思想，自动维护View 性能比较高。单向数据流。angular需要双向数据绑定、数据同步，任何操作都需要遍历监听器。 React更轻量仅仅负责View层，angular是大而全的MVC framework React与其他框架兼容好，angular自成一体 React简单易学，angular学习难度大。 React比较新，框架不稳定，以后发展过程中可能API变动会比较大。还有很多坑要踩。 ##ReactNative 因为React轻量，功能单一的特点。需要配合Flux 的开发模式。才可以成为ReactNative的基础。 123456789101112131415161718192021222324252627import React, &#123; Component,&#125; from &apos;react&apos;;import &#123; Text &#125; from &apos;react-native&apos;;class GeoInfo extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; position: &apos;unknown&apos; &#125;; &#125;, componentDidMount() &#123; navigator.geolocation.getCurrentPosition( (position) =&gt; this.setState(&#123;position&#125;), (error) =&gt; console.error(error) ); &#125; render() &#123; return ( &lt;Text&gt; Position: &#123;JSON.stringify(this.state.position)&#125; &lt;/Text&gt; ); &#125;&#125; ##资料 ReactJS官网 Github ReactJS中文网 reactnative官网 reactnative中文网 虚拟DOM diff算法 虚拟DOM diff算法","tags":[]},{"title":"本地化cocoapods","date":"2017-03-29T13:00:00.000Z","path":"2017/03/29/本地化cocoapods/","text":"一、为什么本地化管理ios是通过cocopods管理框架的。而我们会使用很多在github上的第三方框架是，有时我们会有需要更改第三方框架的需求，把第三方框架放在本地服务器，本地版本管理就很方便了。可以打我们自己分支的tag。又升级需求时，再从github上拉来代码更新。我们有一些自己的框架（例如网络请求），通过pod管理，也可以通过修改podfile配置文件，一键下拉，切换这些框架的版本。如需修改，再通过git拉下来修改。 关于框架的测试，可以就在框架代码中，添加对应的targe去写demo独立测试。而pod只需要写好配置，可以只导入其中需要使用的框架代码。二、pod如何工作的，需要注意什么通过本地podfile文件配置-&gt;pod库，http://172.19.30.116:2333/oc/andpaycocoapodsspecs/项目名/版本号/xxx.podspec.json-&gt;项目地址git@172.19.30.116:oc/xxx.git-&gt;下载到本地项目目录/pods/xxx-&gt;自动配置本地工程。注意：1、pod库会缓存到本地~/Desktop/.cocoapod/Spec/目录下。2、pod install后，项目目录下会产生Podfile.lock，Manifest.lock两个缓存文件。三、如何在andpayCocopodsSpec创建一个项目并使用添加自己的项目指向1、以ACTerm为例，在http://172.19.30.116:2333/oc/ACTerm下创建好自己的项目。2、在http://172.19.30.116:2333/oc/andpaycocoapodsspecs的Spec下添加ACTerm/2.0.0/ACTerm.podspec.json 一级目录是项目名，二级目录是版本号，三级目录是ACTerm.podspec内容的json文件。文件写法介绍http://guides.cocoapods.org/syntax/podspec.html#deprecated_in_favor_of3、ACTerm.podspec.json主要功能指向下载地址-&gt;git@172.19.30.116:oc/ACTerm.git和tag版本。以及下载内容的目录配置和引用的框架等。 四、迁移github上的三方库到gitlab1、例如afnetwork，从github导入本地在刚创建afnetwork的git工作目录下， $git remote add other https://afnetwork地址$git fetch other$git checkout -b ZZZ other/master$git checkout master$git merge ZZZ$git commit$git remote rm other$git branch -d ZZZ$git push –set-upstream origin master$git push origin –tags 本地就会有项目github上的全部release tag2、与添加自己的项目指向方法一样，配置对应的afnetwork.podspec.json3、Podfile中添加 source &#39;git@172.19.30.116:oc/andpaycocoapodsspecs.git’ pod ‘afnetwork’,’~&gt; 0.0.1’ 五、pod使用1、创建specpod spec create ‘name’2、查看repopod repocd ~/.cocopods/repo 七、配置gitlabgitlab for macssh-keygen -t rsa -C“zhiqiang.tang@andpay.me”cat ~/.ssh/id_rsa.pub 八、切换pod版本1， 卸载 cocoapods$ sudo gem uninstall cocoapods 安装 xcodeproj$ sudo gem install xcodeproj 安装指定0.34.4版本的 Cocoapodssudo gem install cocoapods -v 0.35.0 九、cocoapods仓库镜像http://akinliu.github.io/2014/05/03/cocoapods-specs-/ http://git.oschina.net/akuandev/Specshttps://gitcafe.com/akuandev/Specs.git #####扩展参考cocoapods使用参考https://cocoapods.org/","tags":[]},{"title":"Xcode Plugin","date":"2017-02-15T13:00:00.000Z","path":"2017/02/15/Xcode Plugin/","text":"##插件的初始化的配置,调试 ####1、创建一个bundle工程也可以通过下载模板插件创建工程。 ####2、plist配置 XCPluginHasUI = NO XC4Compatible = YES 插件支持的xcode版本 DVTPlugInCompatibilityUUIDs ####3、当前Xcode的uuid defaults read /Applications/Xcode.app/Contents/Info DVTPlugInCompatibilityUUID ####4、插件安装目录 Installation Build Products Location 设置为 ${HOME} [显示的时候,显示的是你的用户目录],这个是products的根目录 Installation Directory 设置为 ~/Library/Application Support/Developer/Shared/Xcode/Plug-ins,这个是指定你的插件安装的目录. 注意,这里填入的其实是相对目录 Deployment Location 设置为 YES,这个是指示该工程不使用设置里的build location Wrapper extension 设置为 xcplugin,后缀名必须为xcplugin,否则不会被加载 ####5、skip bundle defaults delete com.apple.dt.Xcode DVTPlugInManagerNonApplePlugIns-Xcode-7.2.1 ##找想要修改的功能 ####1、断点找具体事件通知 [notification.name isEqualToString:@”NSWindowWillOrderOffScreenNotification”] po notification.object ####2、查找发出通知的对象搜索任何的加载到xcode进程中的frameworks，libraries，plugins，查找该对象的相关信息 (lldb) image lookup -rn DVTBezelAlertPanel ####3、为initWithIcon:message:方法添加断点 父Xcode依然停留在断点出，输入以下命令 (lldb) rb ‘DVTBezelAlertPanel\\ initWithIcon:message:’Breakpoint 1: 2 locations. (lldb) br l ####4、运行到断点处register read的缩写，它是用来输出当前你机器上可见的重要寄存器内容的命令。 (lldb) re re ####5、ios 消息objc_msgSend(DVTBezelAlertPanel, @selector(initWithIcon:message:), @”Build Succeeded”) re re 查看第三个参数po $rdx 1234567$rdi:这个寄存器代表传递给方法的参数self，这也是第一个传递的参数。$rsi:表示Selector，这是传递给的第二个参数$rdx:传递给函数的第三个参数，也是我们看到的Objective-C的第一个参数(因为self和Selector是隐含的参数)$rcx:传递给函数的第四个参数，也是我们看到的Objective-C的第2个参数(因为self和Selector是隐含的参数)$r8:传递给函数的第五个参数。如果需要传递更多的参数，$r9将会作为跟随之后的第6个参数的栈帧$rax:函数的返回值存放在此寄存器中。例如，当我们执行完方法-[aClass description]，$rax将会存放aClass对象的描述NSString。 ##扩展lldb的Dtrace调试工具，也可以探查到方法调用栈。 ##参考1、Alcatraz插件管理工具 http://www.cocoachina.com/ios/20160308/15476.htmlhttp://www.cocoachina.com/ios/20160308/15587.htmlhttp://www.cocoachina.com/ios/20160318/15664.html","tags":[]},{"title":"express --基于 Node.js 平台的 web 开发框架。","date":"2017-01-21T13:00:00.000Z","path":"2017/01/21/express/","text":"###当前最流行的nodejs web框架比较：相对于java web框架，mysql+springMVC+angular技术栈长，分层笨重，搭建慢。 (MEAN)mongo+express+angular+nodejs做到js全栈，开发简单，搭建快捷。由于是基于nodejs，也继承了nodejs 一切优点。比如非阻塞异步io，适合处理高并发。占用资源少。易上手等等。 ###connectconnect是nodejs的中间件框架. express是基于connect扩展而来的， var connect = require(‘connect’);var http = require(‘http’);var app = connect(); app.use(‘/users’,function(req, res){ res.end(‘Hello from Connect!\\n’);}); http.createServer(app).listen(3000); Express没有对nodejs功能及特性进行封装，只是增加了web扩展。例如路由、缓存、中间件、cookie、session、template 都有解决方案。 ###web服务端工作流1、传入的 HTTP 请求将到达某个路由器。2、路由器找到合适的控制器来处理该请求。3、控制器从数据库构建一个模型（或一个模型列表）并传递给一个视图。视图将模型与一个模板组合在一起，从而构建 HTML 页面，然后，将完成的输出传递给正在等待的 HTTP 响应。1&gt;路由var express = require(‘express’);var app = express(); // respond with “hello world” when a GET request is made to the homepageapp.get(‘/‘, function(req, res) { res.send(‘hello world’);}); 2&gt;中间件 app.use(‘/users’,function(err, req, res, next) { //处理 next();});3&gt;模板模板引擎 jade（推荐，简洁性能也不错，express默认是jade，所以follow）、ejs 4&gt;cookie session var express = require(‘express’);var session = require(‘express-session’); //如果要使用session，需要单独包含这个模块var cookieParser = require(‘cookie-parser’); //如果要使用cookie，需要显式包含这个模块var RedisStore = require(‘connect-redis’)(session);var app = express();// 设置 Cookieapp.use(cookieParser(‘xiaocc_’)); // 设置 Sessionapp.use(session({ store: new RedisStore({ host: “127.0.0.1”, port: 6379, db: “test_session” }), resave:false, saveUninitialized:false, secret: ‘keyboard cat’})) 5&gt;操作redis，缓存数据var client = require(‘redis’).createClient();client.on(‘error’, function (err) { console.log(‘Error ‘ + err);}); client.set(‘string key’, ‘string val’, redis.print);client.hset(‘hash key’, ‘hashtest 1’, ‘some value’, redis.print); 6&gt;express通过 mongoose框架去对象驱动模块。可以连接好数据库，使db就会处于open状态，建立所谓长连接。 官网上也有通过mongoskin去操作mongo7&gt;测试框架MochaJS、JasmineJS 和 KarmaJS ###调试 debugDEBUG=express:* npm start npm -g install supervisorsupervisor –debug app.jsnpm install -g node-inspectornode-inspector &amp; -p 3000 ###生成器 Express生成器npm install express-generator –gexpress myapp Yeoman 生成器 npm install -g yonpm install -g generator-meanjsyo meanjs app|— controllers| |— articles.server.controller.js| |— core.server.controller.js| |— users.server.controller.js|— models| |— article.server.model.js| |— user.server.model.js|— routes| |— articles.server.routes.js| |— core.server.routes.js| |— users.server.routes.js|— tests| |— article.server.model.test.js| |— user.server.model.test.js|— views |— 404.server.view.html |— 500.server.view.html |— index.server.view.html |— layout.server.view.html ###相关资料 //也是express公司出的web框架http://koa.bootcss.com/#application//nodejs http中间件https://github.com/senchalabs/connect//expresshttps://github.com/expressjs/express //MEANhttps://github.com/meanjs/mean//ui框架https://github.com/Semantic-Org/Semantic-UI","tags":[]},{"title":"git 常用命令","date":"2017-01-15T13:00:00.000Z","path":"2017/01/15/git常用命令/","text":"一、新建代码库 在当前目录新建一个Git代码库$ git init 新建一个目录，将其初始化为Git代码库$ git init [project-name] 下载一个项目和它的整个代码历史$ git clone [url]二、配置Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。 显示当前的Git配置$ git config –list 编辑Git配置文件$ git config -e [–global] 设置提交代码时的用户信息$ git config [–global] user.name “[name]”$ git config [–global] user.email “[email address]”三、增加/删除文件 添加指定文件到暂存区$ git add [file1] [file2] … 添加指定目录到暂存区，包括子目录$ git add [dir] 添加当前目录的所有文件到暂存区$ git add . 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] … 停止追踪指定文件，但该文件会保留在工作区$ git rm –cached [file] 改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed]四、代码提交 提交暂存区到仓库区$ git commit -m [message] 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] … -m [message] 提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a 提交时显示所有diff信息$ git commit -v 使用一次新的commit，替代上一次提交 如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit –amend -m [message] 重做上一次commit，并包括指定文件的新变化$ git commit –amend [file1] [file2] …五、分支 列出所有本地分支$ git branch 列出所有远程分支$ git branch -r 列出所有本地分支和远程分支$ git branch -a 新建一个分支，但依然停留在当前分支$ git branch [branch-name] 新建一个分支，并切换到该分支$ git checkout -b [branch] 新建一个分支，指向指定commit$ git branch [branch] [commit] 新建一个分支，与指定的远程分支建立追踪关系$ git branch –track [branch] [remote-branch] 切换到指定分支，并更新工作区$ git checkout [branch-name] 建立追踪关系，在现有分支与指定的远程分支之间$ git branch –set-upstream [branch] [remote-branch] 合并指定分支到当前分支$ git merge [branch] 选择一个commit，合并进当前分支$ git cherry-pick [commit] 删除分支$ git branch -d [branch-name] 删除远程分支$ git push origin –delete [branch-name]$ git branch -dr [remote/branch]六、标签 列出所有tag$ git tag 新建一个tag在当前commit$ git tag [tag] 新建一个tag在指定commit$ git tag [tag] [commit] 删除本地tag$ git tag -d [tag] 删除远程tag$ git push origin :refs/tags/[tagName] 查看tag信息$ git show [tag] 提交指定tag$ git push [remote] [tag] 提交所有tag$ git push [remote] –tags 新建一个分支，指向某个tag$ git checkout -b [branch] [tag]七、查看信息 显示有变更的文件$ git status 显示当前分支的版本历史$ git log 显示commit历史，以及每次commit发生变更的文件$ git log –stat 显示某个commit之后的所有变动，每个commit占据一行$ git log [tag] HEAD –pretty=format:%s 显示某个commit之后的所有变动，其”提交说明”必须符合搜索条件$ git log [tag] HEAD –grep feature 显示某个文件的版本历史，包括文件改名$ git log –follow [file]$ git whatchanged [file] 显示指定文件相关的每一次diff$ git log -p [file] 显示指定文件是什么人在什么时间修改过$ git blame [file] 显示暂存区和工作区的差异$ git diff 显示暂存区和上一个commit的差异$ git diff –cached [file] 显示工作区与当前分支最新commit之间的差异$ git diff HEAD 显示两次提交之间的差异$ git diff [first-branch]…[second-branch] 显示某次提交的元数据和内容变化$ git show [commit] 显示某次提交发生变化的文件$ git show –name-only [commit] 显示某次提交时，某个文件的内容$ git show [commit]:[filename] 显示当前分支的最近几次提交$ git reflog八、远程同步 下载远程仓库的所有变动$ git fetch [remote] 显示所有远程仓库$ git remote -v 显示某个远程仓库的信息$ git remote show [remote] 增加一个新的远程仓库，并命名$ git remote add [shortname] [url] 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch] 上传本地指定分支到远程仓库$ git push [remote] [branch] 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] –force 推送所有分支到远程仓库$ git push [remote] –all九、撤销 恢复暂存区的指定文件到工作区$ git checkout [file] 恢复某个commit的指定文件到工作区$ git checkout [commit] [file] 恢复上一个commit的所有文件到工作区$ git checkout . 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file] 重置暂存区与工作区，与上一次commit保持一致$ git reset –hard 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit] 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset –hard [commit] 重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset –keep [commit] 新建一个commit，用来撤销指定commit 后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit]十、其他 生成一个可供发布的压缩包$ git archive","tags":[]}]